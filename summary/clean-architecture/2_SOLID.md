- 실제 적용 사례를 많이 알아야 감이 제대로 잡힐듯

### ch 7. Single Responsibility 
- 함수는 하나의 일만 해야 한다는게 SRP가 아님!
- SRP
  - 모듈 = 소스 파일, 액터 = 변경을 요청하는 사람들
  - 하나의 모듈은 오직 `한 액터`에 대해서만 책임져야 한다고 함...
  - `응집된(cohesive)`이라는 단어가 SRP를 잘 나타낸다!!!
  - SRP가 잘 지켜지지 않을 때 해결 방법
    - 각 액터를 처리하는 코드를 분리하기. 근데 그러다보면 코드가 많이 분리되서 추적하기 힘들다고 함. 보완책이 `facade 패턴`이라고 함.

### ch 8. Open-Closed
- 소프트웨어 개체(artifact)는 확장에는 열려 있고, 변경에는 닫혀 있어야 한다고 함. 즉, 변경할 때 코드 많이 수정하지 말라는 뜻인듯. 수정보단 추가해서 덧붙이는게 나은건가...
- 그러기 위해 변경되는 이유가 다른 요소를 적절히 분리하라고 함! (웹툰 때 `document랑 menu처럼` 분리하라는거겠지)
  - 어떤 작업을 여러 개의 책임으로 `나누면` 구현이나 변경에 대처하기 훨씬 쉬워지긴 함!
  - 책임 분리 외에 소스코드 의존성도 확실히 조직화해야 한다는데... 어색함
    - 클래스 단위로 분할하고, 컴포넌트 단위로 구분하라고 함.
    - DDD에서처럼 도메인 영역(업무 규칙, 가장 높은 수준의 정책)을 보호하고, 인프라쪽을 덜 보호하듯이 보호 계층구조를 만들라는 말.
    - 정보 은닉...?
- 다시 말하면 OCP는 확장하기 쉬우면서, 시스템이 변경에 너무 많은 영향을 받지 않도록 하기 위한거라고 함..

### ch 9. LisKov Substitution
> S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서
> 
> o2 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다. 
> 
> `derived classes` should be substitutable for their `base classes`
 
- 위 정의에서 S:T = ArrayList:List라고 보면 되는듯한데.. 그래서 뭐..?

- LSP 위반 예시로 정사각형/직사각형 문제라는게 있음.
- LSP가 단순히 List와 ArrayList같은 클래스 디자인에만 적용되는게 아니라, 아키텍처 수준까지도 적용가능하다고 함.
  - JDBC가 LSP의 아키텍처적인 예시라고 볼 수 있는듯. 다른 종류의 DB로 쉽게 교체가능하니까
  - 영속화 API로 JPA를 쓸지, jdbc template을 쓸지 쉽게 바꿀 수 있도록 하는것도 LSP 준수하는건가 


### ch 10. Interface Segregation
- 안쓰는 인터페이스는 구현하지 않도록 하라는 원리라고 함.
  - 참 좋은 원리인듯.
  
    쓰지는 않는데 알고는 있어야 하는것들을 가지고 있는게 ISP 위반하는거니까. 자기가 필요한 것만 가지고 있는다는게 매력적

- 불필요한 것들을 포함(즉, import)하면 변경에 따른 불필요한 재컴파일, 재배포가 필요하다고 함.

  근데 재컴파일, 재배포하는게 그렇게 문제되는건가?

- `불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠진다고 함!`


### ch 11. Dependency Inversion
- 유연성이 극대화된 시스템.
  - 추상에 의존하고 구체에 의존하지 않는 시스템을 말하는데, 항상 추상에 의존할 순 없다고 함 (ex. String 클래스는 구체)
  - 대신 `변동성이 큰 구체적인 요소`에 의존하지 말자는 거라고 함.
  - abstract factory..?
  - 아키텍처 경계... 추상과 구체 컴포넌트






